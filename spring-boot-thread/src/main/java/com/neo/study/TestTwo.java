package com.neo.study;import java.util.concurrent.*;/** * Created by cainiao on 2020-08-27 20:21 */public class TestTwo {    //要保证当前系统中线程池只有一个，每个异步任务直接交给线程池，让线程池去执行。    public static ExecutorService executor = Executors.newFixedThreadPool(10);    public static void main(String[] args) throws Exception {        thread();    }    public static void thread() throws Exception {        /**         * 1、继承Thread         *         Thread01 thread01 = new Thread01();         *         thread01.start();         * 2、实现Runnable接口         *          Runnable01 runnable01 = new Runnable01();         *         new Thread(runnable01).start();         * 3、实现Callable接口 + FutureTask(可以拿到返回结果，可以处理异常)         *          FutureTask<Integer> futureTask = new FutureTask<>(new Callable01());         *         new Thread(futureTask).start();         *         //阻塞等待，等待整个线程执行完成，获取返回结果         *         Integer integer = futureTask.get();         * 4、线程池         *      给线程池直接提交任务         *      1、线程池的创建         *          1、Executors         *          2、new ThreadPoolExecutor()         *         * 区别：         * 1、2 方式不能得到返回值 3 可以得到返回值         * 但是前三个都不能控制资源。         * 4可以控制资源，系统性能稳定。         */        //在业务代码里，以上三种启动线程的方式都不使用。应该将所有线程异步任务都交给线程池执行。//        new Thread(()-> System.out.println("hello thread")).start();//        service.execute(new Runnable01());        /**         * 线程池的七大参数         * @param corePoolSize the number of threads to keep in the pool, even         *        if they are idle, unless {@code allowCoreThreadTimeOut} is set         * 核心线程数，一直存在，除非设置了允许超时时间。线程池创建好以后就准备就绪         * @param maximumPoolSize the maximum number of threads to allow in the         *        pool         * 最大线程数，控制资源         * @param keepAliveTime when the number of threads is greater than         *        the core, this is the maximum time that excess idle threads         *        will wait for new tasks before terminating.         * 释放空闲线程（maximumPoolSize-corePoolSize），只要线程空闲大于指定的keepAliveTime         * @param unit the time unit for the {@code keepAliveTime} argument         * 时间单位         * @param workQueue the queue to use for holding tasks before they are         *        executed.  This queue will hold only the {@code Runnable}         *        tasks submitted by the {@code execute} method.         * 阻塞队列，如果任务有很多，就会将目前多的任务放在队列里。只要有线程空闲了，就会去队列里面取出新的任务继续执行         * @param threadFactory the factory to use when the executor         *        creates a new thread         * 线程的创建工厂         * @param handler the handler to use when execution is blocked         *        because the thread bounds and queue capacities are reached         * 如果队列满了，按照指定的拒绝策略，拒绝执行任务。         *         * 工作顺序：         *    1、线程池创建，准备好core线程数量的核心线程，准备接收任务         *    2、当core满了，就会把再进来的任务放进阻塞队列中，空闲的core就会自己去阻塞队列里获取任务执行         *    3、阻塞队列满了，就会开新线程执行，最大能开到max指定的数量         *    4、max满了就用RejectedExecutionHandler拒绝任务         *    5、max都执行完成，有很多空闲线程，在指定的时间keepAliveTime以后释放max-core这些线程         *         *注意：         *    new LinkedBlockingDeque<>(100000)默认是开启最大的，要根据自己系统来手动指定.可以根据压力测试来指定。         *         * 拒绝策略：         *    DiscardOldestPolicy  丢弃最老的任务         *    AbortPolicy           丢弃新来的任务，并抛出异常         *    CallerRunsPolicy      直接调用run方法执行，应该是调用线程执行的。         *    DiscardPolicy         丢弃当前任务，并不抛出异常         *         *         *面试题：一个线程池 core 7 max 20 queue 50         *                问 100并发进来如何分配？         *                答：首先7个线程拿七个任务执行，剩下的93个，50个进了队列 再开13个新线程 剩下30个根据丢弃策略丢掉。         *         */        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5,200,10,TimeUnit.SECONDS,new LinkedBlockingDeque<>(1111),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());        //核心线程数        //最大线程数        //释放空闲线程时间阙值        //时间单位        //阻塞队列        //线程的创建工厂        //丢弃策略    }}