package com.neo.study;import java.util.concurrent.*;/** * Created by cainiao on 2020-08-27 20:21 */public class Test {    //要保证当前系统中线程池只有一个，每个异步任务直接交给线程池，让线程池去执行。    public static ExecutorService executor = Executors.newFixedThreadPool(10);    public static void main(String[] args) throws Exception {        System.out.println("method begin");        //异步编排测试 使用自己指定的线程池//        CompletableFuture.runAsync(()->{//            System.out.println("当前线程"+Thread.currentThread().getId());//            int i = 10/2;//            System.out.println("运行结果："+i);//        },executor);        /*CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {            System.out.println("当前线程" + Thread.currentThread().getId());            int i = 10 / 0;            System.out.println("运行结果：" + i);            return i;        }, executor).whenComplete((t,u)->{            //whenComplete可以得到异常信息，类似监听器，但是没法修改结果            //t 是结果  u 是异常            System.out.println("异步任务成功完成了,结果是："+t+"异常是："+u);        }).exceptionally(throwable -> {            //exceptionally 可以感知异常，同时返回默认值            return 10;        });*/        //方法完成后的处理        /*CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {            System.out.println("当前线程" + Thread.currentThread().getId());            int i = 10 / 0;            System.out.println("运行结果：" + i);            return i;        }, executor).handle((res,thr)->{            if (res != null){                return res*2;            }            if (thr != null){                return 0;            }            return 0;        });*/        /**         * 线程串行化         * 1、thenRunAsync 不能获取到上一步的执行结果         */        /*CompletableFuture<Void> future = CompletableFuture.supplyAsync(() -> {            System.out.println("当前线程" + Thread.currentThread().getId());            int i = 10 / 1;            System.out.println("运行结果：" + i);            return i;        }, executor).thenRunAsync(()->{            System.out.println("线程2启动了");        },executor);        System.out.println("method end");*/        /**         * 2、thenAcceptAsync 能接收上一步结果，但是无返回值。         */        /*CompletableFuture.supplyAsync(()->{            System.out.println("当前线程id "+Thread.currentThread().getId());            int num = 10/2;            System.out.println("运算结果 "+num);            return num;        },executor).thenAcceptAsync(res->{            System.out.println("上一步的运算结果是 "+res);        },executor);        */        /**         * thenApplyAsync 能接收上一步结果，也有返回值         */        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {            System.out.println("当前线程id " + Thread.currentThread().getId());            int num = 10 / 2;            System.out.println("运算结果 " + num);            return num;        }, executor).thenApplyAsync(res -> {            System.out.println("第二个线程，上一步的运算结果是 " + res);            return "9999" + res;        }, executor);        System.out.println(future.get());        System.out.println("method end");    }    public static void thread() throws Exception {        System.out.println("main start");        /**         * 1、继承Thread         *         Thread01 thread01 = new Thread01();         *         thread01.start();         * 2、实现Runnable接口         *          Runnable01 runnable01 = new Runnable01();         *         new Thread(runnable01).start();         * 3、实现Callable接口 + FutureTask(可以拿到返回结果，可以处理异常)         *          FutureTask<Integer> futureTask = new FutureTask<>(new Callable01());         *         new Thread(futureTask).start();         *         //阻塞等待，等待整个线程执行完成，获取返回结果         *         Integer integer = futureTask.get();         * 4、线程池         *      给线程池直接提交任务         *      1、线程池的创建         *          1、Executors         *          2、new ThreadPoolExecutor()         *         * 区别：         * 1、2 方式不能得到返回值 3 可以得到返回值         * 但是前三个都不能控制资源。         * 4可以控制资源，系统性能稳定。         */        //在业务代码里，以上三种启动线程的方式都不使用。应该将所有线程异步任务都交给线程池执行。//        new Thread(()-> System.out.println("hello thread")).start();//        service.execute(new Runnable01());        /**         * 线程池的七大参数         * @param corePoolSize the number of threads to keep in the pool, even         *        if they are idle, unless {@code allowCoreThreadTimeOut} is set         * 核心线程数，一直存在，除非设置了允许超时时间。线程池创建好以后就准备就绪         * @param maximumPoolSize the maximum number of threads to allow in the         *        pool         * 最大线程数，控制资源         * @param keepAliveTime when the number of threads is greater than         *        the core, this is the maximum time that excess idle threads         *        will wait for new tasks before terminating.         * 释放空闲线程（maximumPoolSize-corePoolSize），只要线程空闲大于指定的keepAliveTime         * @param unit the time unit for the {@code keepAliveTime} argument         * 时间单位         * @param workQueue the queue to use for holding tasks before they are         *        executed.  This queue will hold only the {@code Runnable}         *        tasks submitted by the {@code execute} method.         * 阻塞队列，如果任务有很多，就会将目前多的任务放在队列里。只要有线程空闲了，就会去队列里面取出新的任务继续执行         * @param threadFactory the factory to use when the executor         *        creates a new thread         * 线程的创建工厂         * @param handler the handler to use when execution is blocked         *        because the thread bounds and queue capacities are reached         * 如果队列满了，按照指定的拒绝策略，拒绝执行任务。         *         * 工作顺序：         *    1、线程池创建，准备好core线程数量的核心线程，准备接收任务         *    2、当core满了，就会把再进来的任务放进阻塞队列中，空闲的core就会自己去阻塞队列里获取任务执行         *    3、阻塞队列满了，就会开新线程执行，最大能开到max指定的数量         *    4、max满了就用RejectedExecutionHandler拒绝任务         *    5、max都执行完成，有很多空闲线程，在指定的时间keepAliveTime以后释放max-core这些线程         *         *注意：         *    new LinkedBlockingDeque<>(100000)默认是开启最大的，要根据自己系统来手动指定.可以根据压力测试来指定。         *         * 拒绝策略：         *    DiscardOldestPolicy  丢弃最老的任务         *    AbortPolicy           丢弃新来的任务，并抛出异常         *    CallerRunsPolicy      直接调用run方法执行，应该是调用线程执行的。         *    DiscardPolicy         丢弃当前任务，并不抛出异常         *         *         *面试题：一个线程池 core 7 max 20 queue 50         *                问 100并发进来如何分配？         *                答：首先7个线程拿七个任务执行，剩下的93个，50个进了队列 再开13个新线程 剩下30个根据丢弃策略丢掉。         *         */        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5,200,10,TimeUnit.SECONDS,new LinkedBlockingDeque<>(1111),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());        Executors.newCachedThreadPool();//core=0，线程都会被回收        Executors.newFixedThreadPool(10);//core=max 固定大小        Executors.newScheduledThreadPool(10);//定时任务线程池        Executors.newSingleThreadExecutor();//单线程线程池，后台从队列里获取任务，挨个执行        CompletableFuture<Object> future = new CompletableFuture<>();        System.out.println("main end");    }    public static class Callable01 implements Callable<Integer>{        @Override        public Integer call() throws Exception {            System.out.println("当前线程"+Thread.currentThread().getId());            int i = 10/2;            System.out.println("运行结果："+i);            return i;        }    }    public static class Runnable01 implements Runnable{        @Override        public void run() {            System.out.println("当前线程"+Thread.currentThread().getId());            int i = 10/2;            System.out.println("运行结果："+i);        }    }    public static class Thread01 extends Thread{        @Override        public void run() {            System.out.println("当前线程"+Thread.currentThread().getId());            int i = 10/2;            System.out.println("运行结果："+i);        }    }}