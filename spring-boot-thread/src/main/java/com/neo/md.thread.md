#  CompletableFuture 异步编排主要考虑是否需要上一步的返回值，该方法是否有返回结果。##1. 创建异步对象CompletableFuture提供了四个静态方法来创建一个异步操作* public static CompletableFuture<Void> runAsync(Runnable runnable)* public static CompletableFuture<Void> runAsync(Runnable runnable,Executor executor)* public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)* public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,Executor executor)说明：run开头的方法是没有返回值的，supplyAsync是有返回值的。##2. 计算完成时回调方法* public CompletableFuture<T> whenComplete(BiConsumer<? super T, ? super Throwable> action)* public CompletionStage<T> whenCompleteAsync (BiConsumer<? super T, ? super Throwable> action);* public CompletionStage<T> whenCompleteAsync (BiConsumer<? super T, ? super Throwable> action, Executor executor);* public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn)说明：方法名带Asyn的表示，上一个线程结束后，再开启一个新的线程执行任务，否则继续使用上一个线程。whenComplete方法中，T是结果，U是异常##3. handle方法* public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn)* public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);* public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn, Executor executor);        说明：可对结果做最后的处理，可以处理异常，也可以改变返回值##4. 线程串行化方法* thenApply:有返回值，接下来继续运行一个任务,需要上一步的执行结果* public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)* public <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> fn);* public <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor);---* thenAccept:无返回值，接下来继续运行一个任务,需要上一步的执行结果* public CompletableFuture<Void> thenAccept(Consumer<? super T> action)* public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);* public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor);---* thenRun:无返回值，接下来继续运行一个任务,不需要上一步的执行结果     * public CompletableFuture<Void> thenRun(Runnable action)* public CompletionStage<Void> thenRunAsync(Runnable action);* public CompletionStage<Void> thenRunAsync(Runnable action, Executor executor);说明：加了Async说明是开启一个新的线程执行任务，否则还是使用上一个任务的线程。##5. 俩任务组合 都要完成* runAfterBoth:无返回值，组合俩个future，不需要获取future结果，只需要等俩个future处理完任务后，处理该任务* public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action)* public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action);* public CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor);---* thenAcceptBoth:无返回值，组合俩个future，获取俩个future结果，需要等俩个future处理完任务后，处理该任务。* public <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action)* public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action, Executor executor);* public <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T, ? super U> action);---* thenCombine:有返回值，组合俩个future，获取俩个future结果，需要等俩个future处理完任务后，处理该任务，并返回当前任务的返回值* public <U,V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)* public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn);* public <U,V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn, Executor executor);##6. 俩任务组合 一个完成* applyToEither: 俩个任务有一个执行完成,获取它的返回值,处理任务,并有新的返回值* public <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T, U> fn)* public <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn);* public <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T, U> fn, Executor executor);---* acceptEither:  俩个任务有一个执行完成,获取它的返回值,处理任务,没有新的返回值* public CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)* public CompletionStage<Void> acceptEitherAsync (CompletionStage<? extends T> other, Consumer<? super T> action);* public CompletionStage<Void> acceptEitherAsync (CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor);---* runAfterEither:俩个任务有一个执行完成,不获取它的返回值,处理任务,没有新的返回值* public CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action)* public CompletionStage<Void> runAfterEitherAsync (CompletionStage<?> other, Runnable action);* public CompletionStage<Void> runAfterEitherAsync (CompletionStage<?> other, Runnable action, Executor executor);        ##7. 多任务组合* public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)* public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)