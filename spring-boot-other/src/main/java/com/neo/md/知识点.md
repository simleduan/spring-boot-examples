# 多线程## 死锁的条件，如何打破## JMM## 如何创建线程池，队列都有哪些？拒绝策略都有哪些？任务过多时都是如何处理的（double）## 线程生命周期## synchronized原理（double）## jdk对synchronized做了哪些优化## ReentrantLock## CAS、ABA问题（double）# 集合## ArrayList和LinkedList## 什么是fail—fast？ 是集合的一种错误检测机制，当在迭代遍历它的时候，再去修改它就会出现这个问题。  解决方案：集合使用：CopyOnWriteArrayList，Map使用：ConcurrentHashMap## 解决hash冲突的方法* 开放定址法>遇到冲突的时候，就去寻找下一个空的散列地址，将记录存入* 再哈西法>有多个哈西算法，遇到冲突后，使用下一个哈西算法，增加了计算时间* 链表法>哈西冲突后，通过next将多个键值对连接起来* 建立公共溢出表>将哈西表分成基本表和溢出表俩部分，当基础表发生冲突后，就放入溢出表## HashMap的put、扩容原理，1.7和1.8的数据结构（double）1.7 数组+链表1.8 数组+链表+红黑树(当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树)## ConcurrentHashMap###1.7 Segment + HashEntryConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。###1.8数组+链表（红黑树）ConcurrentHashMap在1.8中的实现，相比于1.7的版本基本上全部都变掉了。首先，取消了Segment分段锁的数据结构，取而代之的是数组+链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)。1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，## 什么是可重入锁# 网络## TCP粘包，为什么出现，如何解决？## TCP如何实现消息可靠性、滑动窗口## TCP三次握手四次挥手## DNS## https原理、可以被攻击么？（double）# 数据库事务## 事务的隔离级别、mysql和oracle默认是什么，都解决了什么问题（double）## 事务的特性（double）## 快照读和当前读## 乐观锁、悲观锁、间隙锁、行锁、表锁的使用场景## B+树、聚簇索引和非聚簇索引（double）## mvcc（double）## redolog、undolog、binlog## 一个表没有索引的结构类型## 索引失效的场景## mysql都有哪些组件# 中间件## RabbitMQ和kafka的架构（double）## 如何保证消息的顺序性## 为什么使用这个中间件（double）## Redis数据类型，底层数据结构（double）## 缓存淘汰算法## 缓存穿透、缓存击穿## 缓存数据库双写（double）# Spring## IOC和AOP的理解及原理（double）## Bean的生命周期（double）1. Student-----> 1 construct    通过构造器实例化bean2. Student-----> 2 setName()    设置对象属性3. Student-----> 3 BeanNameAware.setBeanName()    检查Aware相关接口，并设置相关依赖4. MyBeanPostPorcessor.postProcessBeforeInitialization()5. Student-----> 4 @PostConstruct    初始化方式：@PostConstruct6. Student-----> 5 InitializingBean.afterPropertiesSet()    初始化方式：InitializingBean.afterPropertiesSet()7. Student-----> 6 initMethod()    初始化方式：自定义initMethod()8. MyBeanPostPorcessor.postProcessAfterInitialization()9. Student{name='createName'}10. Student-----> 7 @PreDestroy    销毁方式：@PreDestroy11. Student-----> 8 DisposableBean.destroy()    销毁方式：DisposableBean.destroy()12. Student-----> 9 destroyMethod()    销毁方式：自定义destroyMethod()## 自动注入方式有哪些，两个注解的区别## Spring MVC流程# 微服务## 分布式事务怎么做的（double）## CAP、BASE理论## 如何实现一个RPC框架## 服务熔断如何做的## 令牌桶、漏桶算法## 分布式id如何生成（double）# JVM## 各个区域的内容（double）## 常见OOM（double）## 垃圾收集器、算法## 类加载机制（double）1. 载入    1. 将字节码从不同的数据源转换成二进制流加载到内存中，并生成一个代表改类的class文件2. 验证，对二进制字节流进行校验，为JVM的安全提供保障    1. 保证二进制字节流符合预期(魔数)    2. 是否所有方法都遵循访问控制关键字的限定    3. 方法调用的参数个数和类型是否正确    4. 确保变量在使用前都被正确初始化了    5. 检查变量是否被赋予恰当的类型3. 准备    1. 给类变量分配内存并初始化4. 解析    1. 将常量池的符号引用转换为直接引用5. 初始化    1. 调用构造函数实例化的过程## 内存分配并发问题## 新生代默认多少次晋升老年代## 反射# 算法## 都是一个力扣简单级一个中等级，只不过美团上现场白纸写，阿里是伯乐系统在线做# 项目## 项目中出现各种场景的解决方案java基础hashmap底层Integrer和double    Interger        -128<=Interger<=127 为true，其他为false    Double        都是false多线程线程池作用    省去频繁创建线程，节省资源。线程池有哪几种，区别sychronized和volitae区别JVM内存结构#类加载器##如何确认类的唯一性通过该类的类加载器和该类本身##有哪几种类加载器呢1. 启动类加载器（Bootstrap Class-Loader），加载 jre/lib 包下面的 jar 文件，比如说常见的 rt.jar。2. 扩展类加载器（Extension or Ext Class-Loader），加载 jre/lib/ext 包下面的 jar 文件。3. 应用类加载器（Application or App Clas-Loader），根据程序的类路径（classpath）来加载 Java 类。            #双亲委派模型启动类加载器--->扩展类加载器--->应用程序类加载器--->自定义类加载器。    这种层次模型，叫做双亲委派模型。##工作模式：当收到类加载的请求时，首先会委托给上层类加载器去加载，直到顶层。上层加载不了的自己才去加载。好处：保证一个类的唯一性，只会被一个加载器加载。Mysql如何建索引性能查询Redisredis业务场景分布式锁（没答上）持久化redis数据同时失效后果，答缓存击穿，非业务场景下呢？并发遍历I/O多路复用Spring（不了解）kafka（不了解）