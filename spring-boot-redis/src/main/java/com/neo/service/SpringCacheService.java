package com.neo.service;import com.neo.dao.UserInfoCrudRepository;import com.neo.model.UserInfo;import org.redisson.api.RedissonClient;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.CacheEvict;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.Caching;import org.springframework.stereotype.Component;import java.util.Optional;/** * Created by cainiao on 2020-08-23 19:23 * 整合SpringCache * 1、引入依赖 *  spring-boot-starter-cache、spring-boot-starter-data-redis * 2、写配置 *  2.1 自动配置了哪些 *      CacheAutoConfiguration会导入RedisCacheConfiguration *      自动配置好了RedisCacheManager *  2.2 配置使用redis作为缓存 *          spring.cache.type=redis *  2.3 测试使用缓存 *      @Cacheable: Triggers cache population. *          将数据保存到缓存 *      @CacheEvict: Triggers cache eviction. *          从缓存中删除 *      @CachePut: Updates the cache without interfering with the method execution. *          不影响方法执行，更新缓存 双写模式 *      @Caching: Regroups multiple cache operations to be applied on a method. *          组合以上多个操作 *      @CacheConfig: Shares some common cache-related settings at class-level. *          在类级别共享缓存的相同配置 *      2.3.1 开启缓存功能 *          @EnableCaching *      2.3.2 *          只需要使用注解就可以完成缓存操作 * 3、spring-cache的不足 *  3.1、读模式： *         缓存穿透：查询一个null数据。解决：缓存空数据，cache-null-values=true *         缓存击穿：大量并发来查询一个更好过期的数据。解决：加锁？默认无加锁 *         缓存雪崩：大量key同时失效。解决：加随机时间，加上过期时间。spring.cache.redis.time-to-live=3600000 *  3.2、写模式：(缓存与数据库一致) *          3.2.1、读写加锁 *          3.2.2、引入cannal，感知到mysql的更新去更新缓存 *          3.2.3、读多写多，直接去数据库查询就行 * * 总结： *      常规数据（读多写少，及时性，一致性要求不高的数据)完全可以使用Spring-Cache *      特殊数据 特殊设计 * * */@Componentpublic class SpringCacheService {    @Autowired    private UserInfoCrudRepository userInfoCrudRepository;    @Autowired    private RedissonClient redissonClient;    /**     * 1、每一个需要缓存的数据都来指定要放到哪个名字的缓存。【缓存的分区(按照业务类型分)】     * 2、@Cacheable({"category","product"}) 代表当前方法的结果需要缓存，如果缓存中有，方法不用调用，如果缓存中没有，会调用方法，最后将方法的结果放入缓存     * 3、默认行为：     *  3.1、如果缓存中有，方法不调用     *  3.2、key默认自动生成：缓存的名字::Simplekey[](自主生成的key值)     *  3.3、缓存的value的值，默认使用jdk序列化机制，将序列化后的数据存到redis     *  3.4、默认ttl时间 -1     *     * 希望可以自定义：     * 1、指定生成缓存使用的key       key属性指定，接收一个SpEl     * 2、指定缓存数据的存活时间       在配置文件中修改     * 3、将数据保存为json格式     *      CacheAutoConfiguration会导入RedisCacheConfiguration     *     * sync = true 加锁     * @param id     * @return     *///    @Cacheable(value = {"testDatebase"},key = "'userInfo'")    @Cacheable(value = {"testDatebase"},key = "#root.method.name",sync = true)    public UserInfo springCacheCacheable(long id) {        System.out.println("查询数据库了");        Optional<UserInfo> byId = userInfoCrudRepository.findById(id);        return byId.get();    }    @CacheEvict(value = "testDatebase",key = "'springCacheCacheable'")    public UserInfo springCacheCacheEvict(long id) {        System.out.println("测试删除缓存注解@CacheEvict");        Optional<UserInfo> byId = userInfoCrudRepository.findById(id);        return byId.get();    }    /**     * 同时清除多个key值     * @param id     * @return     */    @Caching(evict = {            @CacheEvict(value = "testDatebase",key = "'springCacheCacheable1'"),            @CacheEvict(value = "testDatebase",key = "'springCacheCacheable2'")    })    public UserInfo springCacheCaching1(long id) {        System.out.println("测试删除缓存注解@CacheEvict");        Optional<UserInfo> byId = userInfoCrudRepository.findById(id);        return byId.get();    }    /**     * 级联更新所有关联的数据     * @CacheEvict 失效模式     * 1、同时进行多种缓存操作 @Caching     * 2、指定删除某个分区下的所有数据 @CacheEvict(value = "testDatebase",allEntries = true)     * 3、存储同一类型的数据，都可以指定成同一个分区。分区名默认就是缓存的前缀     * value是缓存分区     * @param id     * @return     */    @CacheEvict(value = "testDatebase",allEntries = true)    public UserInfo springCacheCaching2(long id) {        System.out.println("测试删除缓存注解@CacheEvict");        Optional<UserInfo> byId = userInfoCrudRepository.findById(id);        return byId.get();    }}