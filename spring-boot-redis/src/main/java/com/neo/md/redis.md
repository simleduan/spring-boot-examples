# 分布式锁加锁要做成原子性的占坑和过期时间要一条命令完成获取锁对比，再删除锁，也要是一个原子操作# redis分布式锁核心http://www.redis.cn/commands/set.html1、加锁保证原子性2、解锁保证原子性## 版本一1. 占有锁2. 执行业务逻辑3. 删除锁4. 返回数据5. 当锁被别的线程占有，则自旋存在问题：当业务逻辑出错，锁不会释放。解决方案见版本二## 版本二1. 占有锁，并且设置锁的过期时间2. 执行业务逻辑3. 删除锁4. 返回数据5. 当锁被别的线程占有，则自旋存在问题：设置锁过期时间突然断电，导致锁不会释放。解决方案，让加锁和设置锁过期时间在一个原子操作内## 版本三set lock lockvalue EX 300 NX命令解析：给redis设置一个键为lock值为lockvalue的键值对，过期时间为300秒，不存在才设置ttl lock命令解析：查询该键的剩余有效时间删除锁的问题：1. 业务执行时间超长2. 删除锁的时候，锁已经过期失效了,可能就把别人的锁删掉了。所以要保证删掉的是自己的锁。## 版本四if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1]) else return 0 endif redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end## 版本五锁的自动续期# 分布式锁框架https://github.com/redisson/redisson# JUC锁redissen解决了俩个问题：lock.lock();默认30秒超时时间1.锁的自动续期，看门狗，如果业务超长，运行时期自动给锁续上新的30s，不用担心业务时间长，锁自动过期被删除掉。2.加锁的业务代码只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认在30s后自动删除。# 缓存数据一致性问题缓存里面的数据如何和数据库保持一致缓存数据一致性，解决方案：1. 双写模式 容易产生脏数据2. 失效模式# 缓存一致性解决之Canal                                                       