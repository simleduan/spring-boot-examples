package com.neo.controller;import org.redisson.api.*;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.web.bind.annotation.*;import java.util.UUID;import java.util.concurrent.TimeUnit;/** * Created by cainiao on 2020-08-23 16:11 */@RestControllerpublic class RedissonController {    @Autowired    private RedissonClient redissonClient;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @RequestMapping("redis/hello")    public void hello(){        RLock lock = redissonClient.getLock("my-lock");        //1.锁的自动续期，如果业务超长，运行期间会自动给锁续上新的30s。不用担心业务时间长，锁自动被删掉        //2.加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认在30s以后自动删除。        //rLock.lock();        lock.lock(30, TimeUnit.SECONDS);  //10秒自动解锁，自动解锁时间一定要大于业务的执行时间        //问题：rLock.lock(10, TimeUnit.SECONDS);  在锁时间到了以后，不会自动续期        //1.如果我们传递了锁的超时时间，就发送给redis执行脚本，进行占锁，默认超时就是我们指定的时间。        //2.如果我们未指定锁的超时时间，就使用30*1000的LockWatchTimeout看门狗的默认时间；        // 只要占锁成功，就会启动一个定时任务，每隔10s都会自动续期        //建议； rLock.lock(30, TimeUnit.SECONDS); 省掉了续期的时间        try {            System.out.println("加锁成功执行业务代码"+Thread.currentThread().getId());            Thread.sleep(30000);        } catch (Exception e){        } finally {            System.out.println("finally释放锁"+Thread.currentThread().getId());            lock.unlock();        }    }    //保证一定能读到最新数据，修改期间，写锁是一个排他锁(互斥锁)。读锁是一个共享锁    //写锁没释放读就必须等待    //读 + 读： 相当于无锁，并发读，只会在redis中记录好，所有当前的读锁。他们都会同时加锁成功    //写 + 读： 等待写锁释放    //写 + 写： 阻塞方式    //读 + 写： 有读锁。写也需要等待    //只要有写的存在，都必须等待。    @GetMapping("redis/write")    public String writeValue(){        RReadWriteLock lock = redissonClient.getReadWriteLock("rw-lock");        String s = "";        RLock rLock = lock.writeLock();        try {            rLock.lock();            s = UUID.randomUUID().toString();            stringRedisTemplate.opsForValue().set("writeValue",s);        } catch (Exception e) {            e.printStackTrace();        }finally {            rLock.unlock();        }        return  s;    }    @GetMapping("redis/read")    public String read(){        RReadWriteLock lock = redissonClient.getReadWriteLock("rw-lock");        String s = "";        RLock rLock = lock.readLock();        try {            rLock.lock();            Thread.sleep(30000);            s = stringRedisTemplate.opsForValue().get("writeValue");        } catch (InterruptedException e) {            e.printStackTrace();        }finally {            rLock.unlock();        }        return  s;    }    /**     * 放假，锁门     * 五个班全部都走了，才可以锁大门。     *     * @return     */    @GetMapping("redis/lockDoor")    public String lockDoor() throws Exception {        RCountDownLatch door = redissonClient.getCountDownLatch("door");        door.trySetCount(5);//等待五个班的人走        door.await();//等待闭锁都完成        return  "放假了";    }    @GetMapping("redis/go/{classid}")    public String go(@PathVariable long classid){        RCountDownLatch door = redissonClient.getCountDownLatch("door");        door.countDown();//计数减少1        return  classid+" 班的人都走了";    }    /**     * 信号量     * 车库停车     * 3个车位     *     * @return     */    @GetMapping("redis/car/park")    public String park() throws Exception {        RSemaphore park = redissonClient.getSemaphore("park");        park.acquire();//获取一个信号，获取一个值，阻塞方法。        return "停车 ok";    }    /**     * 信号量     * 车库停车     * 3个车位     *     * @return     */    @GetMapping("redis/car/go")    public String carGo() throws Exception {        RSemaphore park = redissonClient.getSemaphore("park");        park.release();//释放一个车位        return "释放 ok";    }}